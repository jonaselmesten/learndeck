{"courseName":"C++ 1","courseId":52,"cards":[{"cardId":176,"difficulty":1.0,"cardComponents":[{"textArea":"What are the differences between references and pointers?"},{"separator":1920},{"textArea":"Both references and pointers can be used to change local variables of one function inside another function. Both of them can also be used to save copying of big objects when passed as arguments to functions or returned from functions, to get efficiency gain.\nDespite above similarities, there are following differences between references and pointers.\n\nReferences are less powerful than pointers\n1) Once a reference is created, it cannot be later made to reference another object; it cannot be reseated. This is often done with pointers.\n2) References cannot be NULL. Pointers are often made NULL to indicate that they are not pointing to any valid thing.\n3) A reference must be initialized when declared. There is no such restriction with pointers\n\nDue to the above limitations, references in C++ cannot be used for implementing data structures like Linked List, Tree, etc. In Java, references don’t have above restrictions, and can be used to implement all data structures. References being more powerful in Java, is the main reason Java doesn’t need pointers.\n\nReferences are safer and easier to use:\n1) Safer: Since references must be initialized, wild references like wild pointers are unlikely to exist. It is still possible to have references that don’t refer to a valid location (See questions 5 and 6 in the below exercise )\n2) Easier to use: References don’t need dereferencing operator to access the value. They can be used like normal variables. ‘&’ operator is needed only at the time of declaration. Also, members of an object reference can be accessed with dot operator (‘.’), unlike pointers where arrow operator (->) is needed to access members."}]},{"cardId":177,"difficulty":1.0,"cardComponents":[{"textArea":"What are virtual functions – Write an example?"},{"separator":1920},{"textArea":"Virtual functions are used with inheritance, they are called according to the type of object pointed or referred, not according to the type of pointer or reference. In other words, virtual functions are resolved late, at runtime. Virtual keyword is used to make a function virtual.\n\nFollowing things are necessary to write a C++ program with runtime polymorphism (use of virtual functions)\n1) A base class and a derived class.\n2) A function with same name in base class and derived class.\n3) A pointer or reference of base class type pointing or referring to an object of derived class.\n\nFor example, in the following program bp is a pointer of type Base, but a call to bp->show() calls show() function of Derived class, because bp points to an object of Derived class."}]},{"cardId":178,"difficulty":1.0,"cardComponents":[{"textArea":"What is a pointer?"},{"separator":1920},{"textArea":"The ‘this’ pointer is passed as a hidden argument to all nonstatic member function calls and is available as a local variable within the body of all nonstatic functions. ‘this’ pointer is a constant pointer that holds the memory address of the current object. ‘this’ pointer is not available in static member functions as static member functions can be called without any object (with class name)."}]},{"cardId":179,"difficulty":1.0,"cardComponents":[{"textArea":"What are VTABLE and VPTR?"},{"separator":1920},{"textArea":"vtable is a table of function pointers. It is maintained per class.\nvptr is a pointer to vtable. It is maintained per object (See this for an example).\nCompiler adds additional code at two places to maintain and use vtable and vptr.\n1) Code in every constructor. This code sets vptr of the object being created. This code sets vptr to point to vtable of the class.\n2) Code with polymorphic function call (e.g. bp->show() in above code). Wherever a polymorphic call is made, compiler inserts code to first look for vptr using base class pointer or reference (In the above example, since pointed or referred object is of derived type, vptr of derived class is accessed). Once vptr is fetched, vtable of derived class can be accessed. Using vtable, address of derived derived class function show() is accessed and called."}]}]}